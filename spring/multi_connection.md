### 이벤트 루프의 개념과 사용할때의 주의점

이벤트 루프는 동시성을 제공하기 위한 프로그래밍 모델을 말한다. 특정 이벤트가 발생할때까지 대기하다가 이벤트가 발생하면 디스패치해 처리하는 방식으로 작동한다.

이벤트 루프를 사용할때는 **이벤트 루프 쓰레드를 블록하지 않는게** 매우 중요하다.이벤트 루프 쓰레드를 사용해서 동기 I/O 처리를 하면 블록이 되기 때문에 성능이 매우 느려진다.

### I/O 멀티플렉싱

**소켓** 
- 서버와 클라이언트 두 프로세스가 특정 포트를 통해 양방향 통신이 가능하도록 만들어 주는 추상화된 장치이다.
- 소켓에는 수신 버퍼와 송신 버퍼가 존재한다. 데이터가 들어오면 수신 버퍼에 쓰이고, 데이터를 보낼때는 송신 버퍼에 데이터를 쓴다.

### 소켓 통신의 과정
![multiplex1.png](/image/multiplex1.png)
서버 소켓은 listen 메서드를 실행하고 이를 통해 클라이언트로부터 연결 요청이 오기를 기다린다. 클라이언트가 connect 메서드를 호출하고 Listening socket이 accept를 하면 그때 클라이언트와의 데이터 통신을 위한 별도 소켓을 반환한다.

문제점
- 하나 이상의 클라이언트 연결은 서버 리스닝 소켓의 Listen 큐에 들어가있어야 한다. 즉, 동시 처리 성능이 매우 떨어진다. 이를 해결하기 위해 **다중 접속 서버**가 필요하다.

### 다중 접속 서버를 구현하는 방법

- 멀티 프로세싱
- 멀티 쓰레딩
- 멀티 플렉싱 (입출력 대상을 묶어서 관리)

**멀티 프로세싱**

![스크린샷 2023-03-06 오후 8.51.43.png](/image/multiplex2.png)

부모 프로세스에서 리스닝 소켓을 통해서 accept를 호출하고 자식 프로세스를 fork해서 요청을 넘겨준다.


장점
- 프로그램 흐름이 단순하기 때문에 이해하기 쉽다.
- 서로 독립된 메모리 공간을 갖고 각 프로세스는 서로 영향을 미치지 않기 때문에 독립적으로 수행이 가능하다.

단점
- 프로세스 복사가 필요하기 때문에 리소스를 많이 사용한다.
- 병렬로 처리해야 하는 수만큼 프로세스를 생성해야 한다.
- 서로 다른 독립적인 메모리 공간을 갖기 때문에 프로세스간 정보 교환이 어렵다.

**멀티 쓰레딩**

![스크린샷 2023-03-06 오후 8.51.52.png](/image/multiplex3.png)

메인 쓰레드가 리스닝 소켓을 통해 accept를 호출하고 별도의 워커 쓰레드들로 요청을 넘겨준다.

장점
- 프로세스 복사 비용보다 스레드 생성 비용이 적다.
- 서로 공유하는 메모리가 있기 때문에 스레드간 정보 교환이 쉽다.

단점
- 하나의 스레드에서 발생한 문제가 프로세스 전체에 영향을 미쳐 나머지 다수의 스레드에 영향을 끼칠 수 있다.
- 멀티프로세싱 방식보다는 비용이 적게 들지만 스레드 관리에 여전히 많은 리소스가 필요하다.
- 일정 크기의 스레드를 생성해 풀로 관리하며 운영할 수 있지만 요청마다 스레드를 무한정 생성할 수 없기 때문에 많은 수의 요청을 동시에 처리할 수 없다(C10k problem을 해결하지 못한다).

I/O 멀티플렉싱 기법을 사용한다면, 각 클라이언트마다 별도 스레드를 이용하는 게 아니라, 하나의 스레드에서 다수의 클라이언트에 연결된 소켓(파일 디스크립터)을 관리하면서 소켓에 이벤트(read/write)가 발생할 때만 해당 이벤트를 처리하도록 구현함으로써 더 적은 리소스를 사용하도록 개선할 수 있습니다.

**블로킹 I/O**

![스크린샷 2023-03-06 오후 8.52.02.png](/image/multiplex4.png)

어플리케이션에서 read를 호출할때의 과정은 다음과 같다

1. 클라이언트에서 데이터가 출발하고 서버의 커널 버퍼에 복사된다.
2. 커널 영역은 어플리케이션이 접근할 수 없기에, 유저 영역의 프로세스 버퍼로 다시 복사가 된다.
3. 이후에 어플리케이션에서 버퍼의 데이터를 처리할 수 있다.

**I/O 멀티 플렉싱**

select를 통해서 read 입출력 함수를 실행할 수 있는 상태가 된 소켓들을 찾는다.
> 읽을 준비가 되었다는건 데이터가 네트워크를 통해 커널 버퍼에 복사가 된 상태를 말한다.
> 이 상태를 readable이라고 하고 이때 read를 호출하면 커널에서 프로세스 버퍼로 데이터를 복사한다.
 
![스크린샷 2023-03-06 오후 8.52.08.png](/image/multiplex5.png)

이때 Select 메서드를 호출하면 하나 이상의 readable 이벤트가 발생할때까지 block이 되고, kernel 버퍼에서 프로세스 버퍼로 복사가 될때도 block 된다.


Select 과정

![스크린샷 2023-03-06 오후 9.10.02.png](/image/multiplex6.png)

파일에 대해 입출력 데이터가 준비될 때까지 이벤트를 기다리는 파일 상태 테이블을 준비한다. 그 후 6개의 파일 중 입출력이 준비된 파일에 대한 이벤트가 발생하면 이벤트가 발생한 파일 디스크립터의 수를 반환한다. 
이후 이벤트가 준비된 파일에 대해 입출력을 수행하는데, 이미 데이터가 준비된 파일에 대해 입출력을 수행하기 때문에 **무한정 대기해야 하는 블록이 발생하지 않을 것**이라는 게 보장된다.

> 읽을 준비가 되었다 -> 네트워크를 통해서 커널로 데이터가 들어왔다. 커널에서 프로세스 버퍼로 데이터 복사하는건 무한정 블록이 될 일이 없다. 

장점
- 단일 프로세스(스레드)에서 여러 파일의 입출력 처리가 가능한 덕분에 동시에 수만 개의 커넥션도 처리할 수 있다. 이를 바탕으로 C10k problem을 해결할 수 있다.
- POSIX 표준을 따르기 때문에 지원하는 운영 체제가 많아 이식성이 좋다.
- 클라이언트 요청마다 처리하기 위한 별도 스레드를 만들지 않기 때문에 컨텍스트 전환(context switching) 오버헤드가 발생하지 않는다.

> 멀티 프로세스와 멀티 쓰레드는 단순히 accept만 하면 새로운 프로세스나 쓰레드를 생성해야 한다. 하지만 멀티플렉싱은 하나의 쓰레드로 많은 수의 쓰레드를 들고 있을 수 있다. 따라서 리소스 과부하 없이 여러 커넥션 들고 있을 수 있다.



단점
- select 함수를 호출해서 전달된 정보는 커널에 등록되지 않은 것이기 때문에 select 함수를 호출할 때마다 매번 관련 정보를 전달해야 한다.
- select 함수의 호출 결과가 이벤트가 발생한 파일 디스크립터의 개수이기 때문에 어떤 파일 디스크립터에서 이벤트가 발생했는지 확인하기 위해서는 매번 fd_set 테이블 전체를 검사해야 한다.
- 검사할 수 있는 파일 디스크립터 개수에 제한이 있다(최대 1024개).
- select 함수를 호출할 때마다 데이터를 복사해야 한다