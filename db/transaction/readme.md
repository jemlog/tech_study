### 트랜잭션 갱신 손실

갱신 손실 문제는 Read-Modify-Write 주기로 쓰기 작업을 실행할때 발생할 수 있다. 갱신 손실 문제가 발생하면 A 트랜잭션이 갱신한 변경 사항이 이후에 변경한 B 트랜잭션에 의해 유실될 수 있다.

갱신 손실 발생 예시
1. 트랜잭션 A가 트랜잭션 진입 후 잔고 1000원을 읽어서 변경 준비
2. 트랜잭션 B가 거의 동시에 트랜잭션 시작 후 같은 1000원을 읽어서 변경 준비
3. 트랜잭션 A가 1000원에서 300원을 차감한 후 변경사항 반영해서 커밋
4. 트랜잭션 B가 1000원에서 500원을 한 후 변경사항 Write 하고 커밋
5. 결과적으로 트랜잭션 A의 변경사항은 유실되고 트랜잭션 B의 변경사항인 현재 잔고 500원만 반영됨

갱신 손실을 해결할 수 있는 방안

- 원자적 쓰기 연산
- 명시적인 잠금 
- 갱신 손실 자동 감지
- Compare-and-Set (CAS) 연산

### 원자적 쓰기 연산
```sql
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```
원자적 연산은 DB 차원에서 제공해주는 동시성 제어 방법이다. Read-modify-Write 연산의 문제를 해결해준다.

원자적 연산은 Read 작업 시 독점적인 잠금을 획득해서 구현한다. 따라서 실제 갱신이 적용될때까지 다른 트랜잭션에서는 해당 객체에 접근할 수 없다. 이 기법을 커서 안정성 기법이라 부르기도 한다.

원자적 연산의 사용 예시
- 몽고 DB의 JSON 문서 지역적 변경시 원자적 연산 제공
- 레디스의 우선순위 큐 같은 데이터 구조 변경에 원자적 연산 제공

원자적 연산에서 주의할 점

단순히 SQL만 사용한다면 원자성이 보장되지만 최근에는 객체 매핑 프레임워크인 ORM을 많이 사용한다. 따라서 원자적 연산 대신 Read-modify-write 연산을 사용하게 될 가능성이 크다. 즉, ORM을 사용하는 최근의 환경에서 궁합이 좋지 않은 방법이라 할 수 있다.

JPA에서의 Read-Modify-Write 연산 예시
```java

// Read
User user = userRepository.findById(userId).orElseThrow();

// Modify
user.changeName("mocha");

// Write
userRepository.save(user);
```

### 명시적인 잠금

명시적인 잠금은 말 그대로 여러 쓰레드가 접근하는 객체에 대해 명시적으로 락을 거는 기법이다. 
```sql

SELECT * FROM user 
where name = 'mocha'
FOR UPDATE ;  
```
FOR UPDATE 구문을 사용하면 트랜잭션 내에서 단순 조회를 하더라도 트랜잭션이 종료되거나 락 Timeout이 만료될때까지 독점적인 락을 가질 수 있게 해준다.

명시적인 락 사용시 주의점

- 명시적인 락은 락을 소유하고 있는 트랜잭션에 문제가 생길 경우 무한정 락을 소유하는 일이 발생, 데드락이 발생할 수 있으므로 락 timeout 설정이 매우 중요하다.
- 하나의 트랜잭션이 락을 오래 들고 있을 경우 동시 처리 성능이 떨어질 수 있음을 주의하자

JPA 환경에서는 Pessimistic Lock을 사용함으로써 명시적인 락 사용이 가능하다.
```java

public interface UserRepository extends JpaRepository<User, Long> {
    
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    User findUserWithPessimisticLocking(String name);
}
```

### 갱신 손실 자동 감지

갱신 손실 감지는 원자적 연산이나 명시적인 잠금을 사용하지 않고, 트랜잭션 관리자가 갱신 손실 감지하면 롤백 시키고 재시도 시키는 방식이다. 갱신 손실 자동 감지 기능을 제공하는 DB도 있고, 미제공하는 DB (MySQL InnoDB)도 있다.

### Compare-and-Set (CAS) 연산

CAS 연산은 데이터를 수정할때 내가 수정을 위해 조회한 데이터가 수정 시점에 변경 되지 않았다는게 확인될때만 수정 사항을 반영하는 방법이다. CAS 연산을 위해서는 여러 쓰레드가 접근하는 객체의 버전을 관리하면 된다. JPA의 Optimistic Locking이 CAS 연산을 구현하는 기법이다.

Optimistic Locking은 엔티티의 버전을 관리함으로써 갱신 손실을 방지한다.

1. 엔티티 수정 전에 해당 엔티티의 버전 정보를 가지고 온다. ex> version 1
2. 엔티티 수정 중, 다른 트랜잭션이 해당 엔티티를 수정한다. 이때 엔티티의 버전값 증가 ex> version 2
3. 엔티티 변경 사항을 커밋하기 위해 엔티티의 version 값을 조회한다. 현재 버전 값이 2이므로 일관성이 깨진 상태이다.
4. 이전 변경사항만 반영이 되고 지금 커밋하려던 수정 사항은 반영되지 않는다.
5. Optimistic Locking은 변경 사항이 반영되지 않기 때문에 재시도 로직을 필수적으로 작성해야 한다.

Pessimistic Locking vs Optimistic Locking

Optimistic Locking은 데드락 발생 가능성은 없지만 롤백 후 재시도의 과정을 거치기 때문에 자원에 동시 접근하려는 트랜잭션이 많은 경우 과부하가 걸릴 수 있다. 
- 자원에 동시 접근 요청이 매우 많은 상황에서는 Pessimistic Locking이 효율적
- 비교적 적은 상황에서는 Optimistic Locking이 효율적

과부하를 줄이지 않고 재시도 하는 방법

- 재시도 간격을 지수적으로 증가 (ex> 1분 -> 2분 -> 4분)

CAS 연산이 필요한 갱신 손실 발생 가능 상황

1. 트랜잭션 A가 락을 획득해서 트랜잭션을 시작함
2. 트랜잭션 B가 락을 획득하기 위해서 대기함
3. 트랜잭션 A의 작업이 지연되서 락 timeout이 초과됨
4. 락을 획득한 트랜잭션 B가 수정 작업을 진행하고 커밋을 함
5. 지연 처리되고 있던 트랜잭션 A가 본인의 수정 사항을 커밋함
6. 결론적으로 트랜잭션 B의 변경사항은 갱신 손실이 일어남

### 정리

트랜잭션을 통한 데이터 정합성이 중요한 금융 도메인에서는 동시성 제어가 중요함. MSA 환경에서는 레디스나 DB의 네임드 락을 통한 분산 락과 CAS 연산의 조합으로 데이터 정합성을 확실히 보장할 수 있음