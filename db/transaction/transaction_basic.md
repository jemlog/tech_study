### 트랜잭션 특징 (ACID)

---

- 원자성

트랜잭션 내에서 실행한 모든 작업들은 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다. 부분 성공이나 부분 실패는 없다.

- 격리성

동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 해야한다. 격리성은 동시성과 관련된 성능 이슈와 직결되어 있다.

- 지속성

한번 성공한 트랜잭션은 그 결과가 항상 기록되어야 한다. 보통 로그로써 디스크에 기록된다. 중간에 시스템 문제가 생겨서 DB가 다운되더라도 로그를 사용해서 원래대로 복구할 수 있어야 한다.

- 일관성

모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. ex> 무결성 제약 조건

### 트랜잭션 격리 수준

---

- Read Uncommited
- Read Commited
- Repeatable read
- serializable

Read Uncommited

---

트랜잭션 1이 데이터를 수정 후, 아직 커밋하지 않았더라도 트랜잭션 2가 그 데이터를 조회할 수 있다.

단점 : 만약 트랜잭션 1이 롤백된다면 트랜잭션 2가 조회한 데이터는 의미가 없어지고 데이터 정합성에 문제가 생긴다. 이 현상을 `dirty read` 라고 한다.

이 격리 수준은 실제로 사용할 수 없는 수준이기에 격리 수준으로 분류되지도 않음 무조건 피해야 한다.

정리 : Dirty Read를 허용하는 격리 수준

Read Committed

---

트랜잭션 1이 특정 데이터를 수정하면 즉시 DB에는 반영이 되지만, 이전 데이터는 언두 영역에 복구용으로 저장된다. 만약 트랜잭션 1이 아직 커밋하지 않은 상태에서 트랜잭션 2가 데이터를 조회한다면 실제 db가 아닌 언두 영역의 데이터를 조회한다.

언두 영역은 트랜잭션이 끝난 후 바로 제거되는 것이 아니라 일정 시간이 지난 후, 더이상 쓸 일이 없다고 판단되면 그때 삭제된다.

이때 언두 영역에 따로 이전 버전을 저장함으로써 dirty read를 방지하는 방식을 `MVCC`라고 한다.

장점 : dirty read는 발생하지 않는다.

단점 : non repeatable read가 발생한다.

→ non-repeatable read

트랜잭션 2가 트랜잭션 시작 후 특정 데이터를 조회한다. 이때 트랜잭션 1이 데이터를 수정하고 커밋을 한다. 그 다음에 트랜잭션 2가 내부적으로 같은 데이터를 호출하면 이번에는 수정된 데이터가 조회된다. 언두 영역도 의미가 없는게 이미 데이터를 수정하고 커밋을 했기 때문에 db에 반영된 데이터를 가지고 온다.

Repeatable read

---

mysql의 innodb에서 사용하는 격리 수준

dirty read와 non-repeatable read가 발생하는 건 막아주지만, phantom read는 못 막는다.

트랜잭션 id를 트랜잭션마다 부여한다. 이때 자신의 트랜잭션 id보다 더 작은 값의 레코드만 사용한다. 만약에 트랜잭션을 시작한후 데이터를 조회할때 자신의 트랜잭션 아이디보다 더 큰 트랜잭션 id로 수정된 값이 있으면 무시하고 언두 영역에 있는걸 사용한다. read commited와 repeatable read의 차이점은 몇번째 버전까지 타고 내려가는지 여부이다. read commited가 하나의 버전, repeatable은 여러 버전!

→ phantom read

트랜잭션 2가 범위 조회를 처음 했을때와, 트랜잭션 1이 중간에 데이터 하나를 추가후 커밋하고 이후에 다시 범위 조회를 했을때 결과 집합이 달라진다. → 언두 영역에는 락을 걸 수 없기 때문!