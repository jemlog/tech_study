## 인덱스

### B-Tree의 데이터 베이스 인덱스 자료 구조 선정 이유

---

### B-Tree vs Red-Black Tree

- 공통점
    - red-black tree와 b-tree 모두 balanced tree로써 **항상 좌우 균형이 유지**되기 때문에 O(logN)의 탐색 시간 복잡도가 유지된다.
    - 항상 균형을 맞추는 과정이 수반되기 때문에 추가 삭제 수정에 시간이 더 소요된다.

- 차이점
    - red-black tree는 하나의 노드에 하나의 데이터만 들어갈 수 있다.
    - B-Tree의 경우 하나의 노드에 여러 데이터가 들어갈 수 있다. MySQL 에서는 하나의 페이지에 인덱스 키가 최대 585개 들어갈 수 있다. 따라서 자식 노드를 그만큼 가질 수 있는 것이다.


하나의 노드에 들어가는 데이터 수가 많다는 건, 탐색을 위한 시간 복잡도가 줄어든다는 의미이다.

하나의 노드 내의 데이터들은 물리 메모리 상의 연속적인 배열로 연결되어 있다. 이미 주소값이 다 계산되어 있기 때문에 따로 탐색에 시간이 들지 않는다. 즉, 랜덤 엑세스가 아니라 순차 엑세스로 조회할 수 있다.

하지만 red-black-tree의 경우 다른 데이터를 참조하기 위해 항상 참조 포인터를 사용해서 이동해야 한다. 주소값을 계산하는 과정은 CPU Intensive한 활동이기 때문에 비용이 많이 든다.

❗️Red-Black Tree와 B-Tree의 시간복잡도는 O(logN)으로 동일하다. 하지만 이는 이론적인 수치의 동일함임. 실제로는 탐색에 있어서 시간 차이가 많이 난다!

### B-Tree vs Array



Array는 조회에 있어서 O(1)의 시간 복잡도를 가진다. 또한 데이터의 정렬 또한 가능하다.

- 배열을 인덱스 자료구조로 사용할 수 없는 이유
    - 수정 삭제 추가에 있어서 O(n)의 비용이 들어감 → 쓰기 성능이 너무 낭비임
    - 반면 B-tree는 쓰기 시간 복잡도도 O(logN)으로 유지된다.

### B-Tree vs Linked List

링크드 리스트는 쓰기 작업에 있어서 소요되는 시간복잡도가 매우 적다.

하지만, 탐색에 있어서 랜덤 엑세스가 아니라 Head 부터 순차적으로 접근해야 한다. 탐색의 시간복잡도 O(n).

### B-Tree vs Hash Index


- Hash Index의 장점
    - 동등 비교를 할 때 시간 복잡도가 O(1)이다
- Hash Index의 단점
    - 정렬이 되지 않기 때문에 범위 검색을 할 수 없다.
    - Like% 검색을 통한 최적화가 불가능 하다.

### Index vs Sorted List

데이터베이스의 Index는 SortedList와 같은 원리이다.

- 데이터를 넣을때마다 정렬을 해줘야 하기 때문에 쓰기 속도가 느리다.
- 쓰기 성능을 희생하고 탐색 속도를 높혔다.




### 인덱스 특징 및 구조

---

b-tree index의 기본 구조

- 가장 상단의 루트 노드
- 가장 하단의 리프 노드
- 중간의 브랜치 노드

리프 노드에는 실제 데이터 레코드에 대한 주소값이 들어간다.

클러스터링 인덱스를 사용하는 InnoDB의 경우 세컨더리 인덱스의 리프 노드에 데이터 레코드 ROWID 말고 PK값이 들어간다.

이때 데이터 파일 내부에서는 바로 데이터 레코드로 들어가는게 아니라, 다시 프라이머리 키를 기준으로 한, 전체 인덱스가 시작된다.

❗️즉, 세컨더리 인덱스를 쓰면 인덱스를 총 2번 타고, 바로 PK로 조회하면 1번 탄다.

### 인덱스 추가 비용

- 만약 테이블에 인덱스가 3개라면, 레코드 하나 추가될때, 결국 그 인덱스 3개를 다 추가해야 한다.
- 레코드를 추가하는 비용이 1, 인덱스에 키값 추가하는 비용이 1.5 라고 예측 시, 인덱스 3개라면 3*1.5 + 1, 총 5.5의 비용이 드는 것이다.

### 인덱스 추가


- innodb 이외의 엔진의 경우, 레코드 추가 시 즉시 인덱스의 키값도 변경
- innodb는 유니크 인덱스나 프라이머리 인덱스의 경우에는 중복 체크를 위해 즉시 반영,
    - 세컨더리 인덱스의 인덱스 키 추가는 잠시 지연시킬 수 있다. (체인지 버퍼에 버퍼링 해놓음)

### 인덱스 삭제

해당 키 값이 저장된 리프 노드 찾아가서 삭제 마크 한다. 이때 삭제 마킹 작업은 디스크 쓰기 필요함

- 체인지 버퍼에 버퍼링 해서 지연 처리 가능

### 인덱스 변경

- 인덱스 키값의 변경 작업은 선 delete 후 Insert의 2개의 과정으로 이뤄진다.
- 키값에 따라 소속되는 리프 노드가 달라지기 때문이다. innodb에서는 전부 지연 처리 가능함

### 중요

레코드를 update 하거나 delete할 경우, 변경할 레코드를 찾기 위해 인덱스를 탄다.

이때 InnoDB의 경우 변경에 사용한 인덱스에 대해 전부 락을 걸고 (Ex update 절에 포함된 where 조건 인덱스)

update와 delete의 경우에도 그 변경할 레코드를 찾기 위해 인덱스를 탄다.

이때 innodb는 변경을 위해 검색한 모든 인덱스에 대해 락을 건 후, 해당하는 레코드 전체에 잠금을 건다.

인덱스 잘못 걸면 잘못하면 모든 레코드를 잠글수도 있음

### 페이지 / 블록

디스크에 데이터를 저장하는 가장 기본 단위

- 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위
- 버퍼풀에서 데이터를 버퍼링 하는 기본 단위
- 인덱스도 페이지 단위로 관리된다

innodb 엔진의 기본 페이지 크기 → 16KB

평균적으로 자식 노드 585개 가질 수 있음!

innodb의 경우 인덱스를 버퍼풀에 캐시해둔다. 하지만 인덱스 키값 길이 길어지면 캐싱할 수 있는 레코드 수 감소

또한 무조건 페이지 단위로 가져오기 때문에 최대한 인덱스 크기를 작게 해서 한 페이지 안에 많이 넣어야 함

높이가 낮을 수록 디스크 액세스 횟수가 줄어듬, 보통 높이가 5 이상으로는 안 늘어남


### MySQL의 인덱스 사용 방법

**인덱스 레인지 스캔**

검색해야 할 인덱스의 범위가 결정됐을때 사용하는 인덱스

1. 인덱스를 통해서 루트 노드부터 리프 노드까지 검색해서 시작점 레코드를 찾는다.
2. 거기서 부터 쭉 스캔을 진행하고, 리프노드의 끝까지 읽으면 다음 노드까지 링크를 통해 이동한다.
    - 쭉 스캔이 가능한 이유 : B+Tree 구조라서 리프 노드가 링크드 리스트로 연결됨

쭉 스캔할때 실제 데이터 파일에서 나머지 정보를 읽어오는 과정을 레코드 한건한건 단위로 I/O가 발생한다.

이 때문에 인덱스를 통해 레코드를 읽는 과정이 비용이 많다고 하고, 가지고 와야하는 데이터가 전체의 25프로 정도가 넘으면 오히려 테이블 스캔이 유리하다.

**인덱스 풀 스캔**

쿼리 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아니면 인덱스 풀 스캔이 걸린다.

- 인덱스는 (a,b,c) 인데 조건에는 b나 c 사용한경우.

❗️위의 2개는 타이트 인덱스 스캔

**루스 인덱스 스캔**

만약 2개 이상의 컬럼이 인덱스로 묶여있다면, 모든 인덱스에 대해서 체크하지 않아도 될 수도 있다. 예를 들어서 1번 컬럼과 2번 컬럼 조합에서 2번 컬럼은 최소값만 구하면 된다면, 첫번째 인덱스만 체크 후, 다음 1번 컬럼 값으로 넘어가도 된다.

**인덱스 스킵 스캔 (8.0에 도입)**

실행 계획 상에서 type이 index인건 인덱스 풀 스캔을 말한다.
만약 (a,b) 인덱스에서 b만 가지고 쿼리를 짜더라도 인덱스 스킵 스캔 활성화하면 옵티마이져가 자동적으로 동등 조건 넣어서 스킵스캔 해줌

- 스킵 스캔이 가능한 조건
    - 선행 컬럼의 유니크 값이 적어야함 즉, 성별 같이 카더널리티가 떨어져야 한다.
        - 만약 카더널리티가 너무 높으면 동등 비교를 해야하는게 너무 많아짐
    - 무조건 커버링 인덱스일때 사용 가능, 아니면 테이블 풀 스캔 해버림

### Index 정렬

- 오름차순 인덱스 : 작은 값의 인덱스가 B-Tree의 왼쪽에서부터 정렬
- 내림차순 인덱스 : 큰 값의 인덱스가 B-Tree의 왼쪽에서부터 정렬
- 인덱스 정순 스캔 : 무조건 인덱스 왼쪽부터 스캔
- 인덱스 역순 스캔 : 무조건 인덱스 오른쪽부터 스캔

❗️역순 스캔이 정순 스캔보다 시간이 오래 걸림

- 인덱스 락이 정순 탐색에 유리하도록 설계됨
- 내부적으로는 인덱스 키끼리 단방향으로 연결되어 있음

→ 페이지 끼리는 Double Linked List로 설계됨 → B+Tree

Desc 쿼리가 많다면 내림차순 인덱스 사용하는게 현명함

→ 내림차순 인덱스 사용하면 정순 스캔 가능하기 때문이다

### 커버링 인덱스

Select 절에서 조회하는 컬럼이 인덱스 내부에 모두 포함되어 있는 경우 커버링 인덱스를 사용한다고 말한다.

인덱스 내부에서 원하는 정보를 모두 가져올 수 있기 때문에 디스크 IO가 발생하지 않는 매우 효율적인 방법이다.

### 인덱스 컨디션 푸시 다운

인덱스 내부에 포함된 컬럼은 범위 검색 조건과 비교 조건이 있다. 범위 검색 조건은 검색해야함 범위를 줄여주지만 비교 조건은 단순 비교를 진행하기 때문에 효율성을 높여주지 못한다.

기존에는 인덱스에 비교 조건이 들어가 있을 경우, MySQL 엔진이 인덱스에서 조건을 사용하지 못하고 직접 레코드에서 비교를 하도록 만들었었다. 하지만 인덱스 컨디션 푸시 다운을 사용하면 범위 검색 조건이 아닌 조건이라도 인덱스에서 최대한 사용해서 검색 조건을 줄일 수 있도록 해준다.

인덱스 조건 필터링 : 스토리지 엔진

레코드에서 조건 필터링 : MySQL 엔진

결론 : 인덱스 컨디션 푸시 다운은 인덱스에서 최대한 범위를 좁히므로써 검색 후 버려지는 레코드를 최소화 시키는 역할을 한다.

ex> 만약에 범위 조건으로 1000건중에 100건을 추렸다. 하지만 나머지 비교 조건을 직접 레코드를 보고 처리했는데 해당하는게 1건 밖에 없다. 그러면 99건은 쓸데없는 디스크 IO가 발생한 것이다.

### 좋은 인덱스 기준

카더널리티 : 높다 → 포함된 요소의 종류의 수

선택도 : 낮다 → 총 개수중 특정 요소의 비율

선택도가 낮아야 버려지는 값을 조회하는 범위를 줄일 수 있다.

- 쿼리의 효율성 지표 → 얼마나 쓸모없는 값들을 조회하지 않았냐 → 다 디스크 I/O와 관련있기 때문!
- ex> 최대한 적게 조회가 되야 조건이 다 걸러졌을때 버려지는 값들이 적다.

❗️일반적으로 인덱스를 통해 읽는 작업이 테이블에서 직접 데이터 1건 가져오는것보다 4~5배 정도 비용이 더 든다고 함.

따라서 효율적이지 않은 방법은 풀 테이블 스캔을 하는게 낫고, 옵티마이져 단에서도 무시한다.

### 인덱스 효율적으로 사용하는 법

update, delete 쿼리도 결국 해당하는 조건의 레코드를 찾아가는 과정이 필요하다.
- 인덱스를 사용하는 컬럼에 대해서 update와 delete를 실행해야 수정 작업이 빠르게 진행된다.

인덱스의 개수는 테이블 당 3~4개가 적당하다. 인덱스가 늘어날수록 레코드가 추가될때마다 수정해야하는 인덱스도 늘어난다. 많은 레코드는 옵티마이져가 잘못된 선택을 하도록 만들 수 있다. 보통 하나의 페이지에 인덱스 레코드 585개가 들어간다.


### 여러 컬럼으로 인덱스 구성시 기준

- 다중 컬럼 인덱스를 구성할때는 카더널리티가 높은 순에서 낮은 순으로 배치해야 한다.
- 다중 컬럼 인덱스를 사용할때 첫번째 키는 무조건 넣어야 한다. 중간 키는 빠져도 된다.
- 다중 컬럼 인덱스에서 조회 순서는 꼭 순서를 지켜야 할 필요 없다.
- 적용 순서는 상관없다고 했다. between, like, > , < 같은 범위 조건을 사용한 경우, 실제 인덱스 구성 순서 상으로 뒤의 키는 인덱스가 적용되지 않는다
-  or 연산자는 비교해야할 ROW가 더 늘어나기 때문에 풀 테이블 스캔이 발생할 확률이 높음

**Group By**

- group by 절에 명시된 인덱스의 순서를 무조건 지켜야 한다
ex > b, c, a 불가능
- group by 절에서 앞 인덱스가 빠지면 안된다
ex> b,c c 안됨
- 만약 앞 인덱스가 빠져있는데 where 절에 동등 조건으로 들어가 있으면 인덱스 타진다
- where 절이 like% 같은 범위 조건이면 인덱스 안타진다
- 커버링 인덱스까지 사용하면 성능 극대화 된다 1m -> 1s

**인덱스 스킵 스캔**
- mysql은 범위 조건이 포함될 경우, 옵티마이져가 자동으로 범위 조건이 가장 뒤로 들어가있는 인덱스를 선택한다.
- 앞 컬럼이 동등 조건으로 들어갈 시에 다중 컬럼 인덱스에서 인덱스 탈 수 있다
- 인덱스 앞의 컬럼을 가능한 모든 요소를 포함해서 in으로 조회할 수 있다.
  - 몇개까지 in 절에 넣으면 되나? **200개를 초과**할 경우 생각지 못한 성능 저하가 발생할 수 있다.


### 인덱스 가용성과 효율성 판단

- NOT EQUAL이 사용되면 인덱스 사용 불가능하다 (<>, not in, not between, is not null)
- Like %?? 형태로 문자열 패턴 비교되는 경우

다중 컬럼 인덱스 케이스 체크
- 첫번째 컬럼이 없거나 첫번째 컬럼이 위의 불가 사유 중 하나인 경우

작업 범위 결정 조건으로 사용 가능한 경우
- 앞의 조건들이 동등 비교 == , in을 사용하는 경우
- 마지막 컬럼이 == , in or > < or Like% 인 경우

ex ) (index1, index2, index3) 으로 구성 시 
```sql
select * from dog where index1 = 'a' and index2 = 'b' and index3 > 'c';
// 모든 컬럼이 작업 범위 결정 조건으로 인덱스에 포함된다.
// 만약 중간에 > < like% 들어오면, 그 다음 컬럼은 체크조건으로 인덱스 포함 안된다.    
```